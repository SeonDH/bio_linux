# [번외] 프로세스와 도커 컨테이너

# 유사점

1. **격리된 실행 환경**
    - **프로세스**: 각 프로세스는 메모리, 파일 핸들, 네트워크 포트 등 자원을 격리된 상태에서 사용한다.
    - **컨테이너**: 컨테이너도 격리된 실행 환경을 제공한다. 각 컨테이너는 자체 파일 시스템, 네트워크 인터페이스 등을 갖추고 있으며, 다른 컨테이너와 자원을 격리하여 사용한다.
2. **동적 생성 및 종료**
    - **프로세스**: 프로세스는 실행 중에 동적으로 생성되고 종료된다.
    - **컨테이너**: 컨테이너도 필요한 경우 동적으로 생성되고, 작업이 완료되면 종료된다.
3. **리소스 관리**
    - **프로세스**: 운영체제는 CPU, 메모리, I/O 등 프로세스의 리소스를 관리한다.
    - **컨테이너**: 도커는 cgroups와 namespaces를 사용하여 각 컨테이너의 CPU, 메모리, 네트워크 등의 리소스를 관리한다.

# 차이점

1. **격리 수준**
    - **프로세스**: 프로세스는 같은 커널 공간을 공유하며, 격리 수준이 낮다.
    - **컨테이너**: 컨테이너는 namespaces와 cgroups를 사용하여 더 높은 수준의 격리를 제공한다. 컨테이너는 파일 시스템, 네트워크, 프로세스 공간 등을 격리한다.
2. **종속성 관리**
    - **프로세스**: 전통적인 프로세스는 호스트 시스템에 설치된 종속성에 의존한다.
    - **컨테이너**: 컨테이너는 종속성을 함께 패키징하여 실행 환경을 완벽하게 재현할 수 있다. 컨테이너 이미지는 필요한 모든 라이브러리와 종속성을 포함한다.
3. **배포 및 이동성**
    - **프로세스**: 전통적인 프로세스는 특정 호스트에 종속되며, 다른 시스템으로 쉽게 이동할 수 없다.
    - **컨테이너**: 컨테이너 이미지는 이식성이 높아, 어디서든 동일한 환경에서 실행될 수 있다. 도커 이미지를 사용하면 애플리케이션을 쉽게 배포하고, 환경 간에 일관성을 유지할 수 있다.
4. **관리 도구**
    - **프로세스**: 전통적인 리눅스 프로세스는 `ps`, `top`, `kill` 등의 명령어로 관리한다.
    - **컨테이너**: 도커 컨테이너는 `docker ps`, `docker stop`, `docker rm` 등의 도커 명령어로 관리한다.

## 예제

### 리눅스 프로세스

```
# 백그라운드에서 sleep 100 프로세스를 실행
sleep 100 &

# 실행 중인 프로세스 목록 보기
ps aux | grep sleep
```

### 도커 컨테이너

```
# 백그라운드에서 도커 컨테이너를 실행
docker run -d --name my-container alpine sleep 100

# 실행 중인 도커 컨테이너 목록 보기
docker ps

# 도커 컨테이너 중지
docker stop my-container

# 도커 컨테이너 삭제
docker rm my-container
```